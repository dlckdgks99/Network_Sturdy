# 4.1 다중처리 기술

### 멀티태스킹
- 여러 작업을 병행하여 처리하는 기법
- 멀티 프로세스
  - 각 프로세스들이 독립적으로 작업을 처리하므로 구현이 간편
  - 병렬처리 해야 할 작업 수만큼 프로세스를 생성하여하 하는 단점
  - 프로세스가 많이 생성될수록 메모리 사용량이 증가하고 스케줄링 횟수도 많아져 프로그램 성능이 떨어짐
  - 프로세스들 사이에 데이터 공유하기 불편
  - 데이터 공유하려면 IPC 통신이 필요해 구현 복잡
- 멀티 스레드
  - 프로세스 내에서 독립적으로 실행되는 작업 단위
  - 새로 만들어진 스레드는 원래 프로세스의 이미지를 같이 사용(공유)
  - 스레드용 스택 영역은 스레드별로 별도로 배정(스택 공유 x)
  - 한 프로세스 내에서 생성된 스레드들은 이미지를 공유(전역변수를 같이 사용)
  - 메모리량 절약 및 생성 시간 짧음
  - 동기화 문제가 발생
 
### 다중화

| 방식  | 작동 방식 | 장점| 단점| 사용 예|
| ------------- | ------------- |------------- |------------- |------------- |
| 폴링  | CPU가 계속 상태 확인 | 구현 쉬움| CPU 낭비 극심| 단순 I/O|
| 셀렉팅  | OS가 준비된 소켓을 알려줌 | 효율적, 서버개발에 주로사용| select,poll은 성능 한계| tcp 서버, 채팅서버|
| 인터럽트  | 장치가 먼저 CPU 깨움 | 가장 효율적| 구현 복잡| 키보드 등 하드웨어|

### 다중처리 예
- 채팅 프로그램
- 멀티프로세스형 서버 프로그램
- 폴링형 서버 프로그램
- 셀렉팅형 서버 프로그램
- 인터럽트형 서버 프로그램

# 4.2 소켓의 동작 모드
- 블록 모드 : 이 소켓에 대해 시스템 콜을 호출하였을 때 시스템이 동작을 완료할때까지 시스템 콜에서 프로세스가 멈추어있는 모드
- 넌블록 모드 : 소켓 관련 시스템 콜에 대하여 시스템이 즉시 처리할 수 있으면 바로 결과를 리턴하고, 즉시 처리할 수 없는 경우라도 시스템 콜이 바로 리턴되어 응용프로그램이 블록되지 않게 하는 소켓
- 비동기 모드 : 소켓에서 어떤 I/O 변화가 발생하면 그 사실을 응용 프로그램이 알 수 있도록하여 그 때 입출력 처리 등 원하는 동작을 하는 모드

# 4.3 비동기형 채팅 프로그램

### 채팅 서버 프로그램 구조

### select()
-단점
  - 감시할 FD가 많아질수록 성능이 느려짐
  - FD_SET을 매번 초기화하고 복사해야 해서 오버헤드가 큼
  - FD 개수 상한: 1024개 (기본 FD_SETSIZE)

### 채팅 서버 프로그램
- 이벤트 기반 비동기형 (select) IO 멀티플렉싱 서버
- tcp_chatcli.c
  - 내가 채팅을 쳤다 => 키보드 이벤트 발생(0),FD_ISSET(0) = true,키보드 처리 if문만 실행됨
  - 다른 클라이언트가 채팅을 쳤다 => 서버 메시지 도착(s),FD_ISSET(s) = true, 서버 메시지 처리 if문만 실행됨
 
# 4.4 폴링형 채팅 프로그램
### fcntl()
### 폴링형 채팅 서버

## 비동기형 채팅(이벤트 기반) vs 폴링형 채팅 비교

| 구분 | 비동기형 채팅 (Async / Event-driven) | 폴링형 채팅 (Polling) |
|------|--------------------------------------|------------------------|
| 메시지 처리 방식 | 데이터가 오면 **즉시 이벤트 발생** | 일정 시간마다 **반복 검사** |
| CPU 사용량 | 낮음 (불필요한 연산 없음) | 높음 (계속 검사해야 함) |
| 지연 시간(Delay) | 거의 없음 | 폴링 주기만큼 늦어짐 |
| 구현 방식 | `select`, `poll`, `epoll`, callback 이벤트 | `sleep`, 무한 반복 루프, HTTP polling |
| 서버 구조 | Push 기반 (서버가 클라이언트에게 즉시 전달) | Pull 기반 (클라이언트가 계속 요청) |
| 실시간성 | 매우 좋음 | 보통 또는 낮음 |
| 확장성 | 높은 성능 (대량 사용자 처리 가능) | 낮음 (사용자가 많아지면 부하 증가) |
| 대표 예 | select 기반 채팅 서버, Node.js 이벤트 루프, WebSocket | 오래된 AJAX 1초 폴링 방식, 무한 루프 polling |

# 🤔 4장에대한 생각
- select 함수
- tcp_listen() 함수
  - 이 함수를 쓴 이유가 무엇일까?
    1. 반복되는 코드를 제거하기 위해(socekt(),bind(),listen() 한번에 묶음)
    2. 에러 처리를 통합하여 깔끔하게 하기위해
    3. 가독성 향상을 위해
    4. 추가 기능을 넣기 쉽기에
  - 함수를 랩핑해두면 코드를 깔끔하고, 반복되는 작업을 캡슐화할 수 있기 때문에 아주 중요한 코드
- FD_ISSET
  - server는 클라이언트수가 늘어남에 감시할 FD가 많아지지만, client는 키보다,server socket 2개만 감시하면된다
- 비동기형 vs 폴링형
